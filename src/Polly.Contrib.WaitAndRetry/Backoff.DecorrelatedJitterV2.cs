using System;
using System.Collections.Generic;

namespace Polly.Contrib.WaitAndRetry
{
    partial class Backoff // .DecorrelatedJitterV2
    {
        /// <summary>
        /// Generates sleep durations in an exponentially backing-off, jittered manner, making sure to mitigate any correlations.
        /// For example: 850ms, 1455ms, 3060ms.
        /// Per discussion in Polly issue 530, the jitter of this implementation exhibits fewer spikes and a smoother distribution than the AWS jitter formula.
        /// </summary>
        /// <param name="meanFirstDelay">The mean delay to target before the first retry, call it f (= f * 2^0).
        /// Choose this value both to approximate the first delay, and to scale the remainder of the series.
        /// Subsequent retries will (over a large sample size) have a mean approximating retries at time f * 2^1, f * 2^2 ... f * 2^t etc for try t.
        /// The actual amount of delay-before-retry for try t may be distributed between 0 and f * (2^(t+1) - 2^(t-1)) for t >= 2;
        /// or between 0 and f * 2^(t+1), for t is 0 or 1.</param>
        /// <param name="retryCount">The maximum number of retries to use, in addition to the original call.</param>
        /// <param name="seed">An optional <see cref="Random"/> seed to use.
        /// If not specified, will use a shared instance with a random seed, per Microsoft recommendation for maximum randomness.</param>
        /// <param name="fastFirst">Whether the first retry will be immediate or not.</param>
        public static IEnumerable<TimeSpan> DecorrelatedJitterBackoffV2(TimeSpan meanFirstDelay, int retryCount, int? seed = null, bool fastFirst = false)
        {
            if (meanFirstDelay < TimeSpan.Zero) throw new ArgumentOutOfRangeException(nameof(meanFirstDelay), meanFirstDelay, "should be >= 0ms");
            if (retryCount < 0) throw new ArgumentOutOfRangeException(nameof(retryCount), retryCount, "should be >= 0");

            if (retryCount == 0)
                return Empty();

            return Enumerate(meanFirstDelay, retryCount, fastFirst, new ConcurrentRandom(seed));

            IEnumerable<TimeSpan> Enumerate(TimeSpan scaleFirstTry, int maxRetries, bool fast, ConcurrentRandom random)
            {
                // A factor used within the formula to help smooth the first calculated delay.
                const double pFactor = 4.0;

                // A factor used to scale the mean values of the retry times generated by the formula to be _near_ whole seconds, to aid Polly user comprehension.
                // This factor allows the mean values to fall approximately at 1, 2, 4 etc seconds, instead of 1.4, 2.8, 5.6, 11.2.
                const double rpScalingFactor = 1 / 1.4d;

                long targetTicksFirstDelay = scaleFirstTry.Ticks;

                int i = 0;
                if (fast)
                {
                    i++;
                    yield return TimeSpan.Zero;
                }

                double prev = 0.0;
                for (; i < maxRetries; i++)
                {
                    double t = (double)i + random.NextDouble();
                    double next = Math.Pow(2, t) * Math.Tanh(Math.Sqrt(pFactor * t));

                    double formulaIntrinsicValue = next - prev;
                    yield return TimeSpan.FromTicks((long)(formulaIntrinsicValue * rpScalingFactor * targetTicksFirstDelay));

                    prev = next;
                }

            }
        }
    }
}